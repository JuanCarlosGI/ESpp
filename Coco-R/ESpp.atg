using System.Collections.Generic;
using System.Linq;

COMPILER ESpp

CHARACTERS
	digit = '0'..'9'.
	lower = 'a'..'z'.
	upper = 'A'..'Z'.
	eol = '\r' + '\n'.
	noQuote = ANY - '\"' - eol.

TOKENS
	id = lower{['_'](lower|upper|digit)}.
	ctestr = '"' {noQuote} '"'.
	cteent = digit{digit}.
	ctedbl = digit{digit}'.'digit{digit}.
	lpar = '('.

IGNORE eol + '\t'

PRODUCTIONS
	ESpp = Program	(. var main = currentCodeBlock.SearchForFunctionScope("main"); if(errors.count == 0) main.CommandList.ExecuteBy(this); .)
		.

	Program	= Vars Funs Main.

	Vars = "variables" ':' {Declaracion}.
	
	Funs = "funciones" ':' {									(. Type funType; .)
		(
			Tipo<out funType>
			|"rutina"											(. funType = Type.Rutina; .)
		)
		id														(. var funName = t.val; .)
		'('														(. var vars = new List<Variable>(); .)
		[														(. Type tipo; .)
			Tipo<out tipo> id									(. vars.Add(new Variable(){Name=t.val, Type=tipo}); .) 
			{
				',' Tipo<out tipo> id							(. vars.Add(new Variable(){Name=t.val, Type=tipo}); .) 
			}
		] ')'													(. addFunction(funName, funType, vars); .)
																(. DirectValueSymbol returns; .)
		Bloque<funName, vars.ToArray(), funType != Type.Rutina, out returns>
																(. addReturns(funName, returns); .)
		}.


	Main =					(. DirectValueSymbol dummy; .) 
		"main" Bloque<"main", new Variable[]{}, false, out dummy>.
	
	Declaracion =					(. Type tipo; bool isArr = false; int size = 0; .)
		Tipo<out tipo> 
		[ TipoArr<out size>			(. isArr = true; .)
		] id						(. addVariable(t.val, tipo, isArr, size); .) 
		{ ',' id					(. addVariable(t.val, tipo, isArr, size); .) 
		} ';'.

	Tipo<out Type tipo> =	(. Type tipoAux = Type.Error; .)
		(
			"entero"		(. tipoAux = Type.Entero; .)
			| "decimal"		(. tipoAux = Type.Decimal; .)
			| "booleano"	(. tipoAux = Type.Booleano; .)
			| "cadena"		(. tipoAux = Type.Cadena; .)
		)					(. tipo = tipoAux; .)	
		.

	TipoArr<out int length> = '[' cteent (. length = int.Parse(t.val); .) ']'.
	
	Bloque<string name, Variable[] parameters, bool isFunction, out DirectValueSymbol returns> =						
		'{'										(. createNewSymbolTable(name, new List<Variable>(parameters)); doPushDefaults(); .)
												(. returns = null; .)
		{
			Declaracion 
			| Condicion 
			| Ciclo 
			| Impresion 
			| IF(FollowedByLPar())							(. Function function; List<DirectValueSymbol> paras; .) 
				Funcion<out function, out paras> ';'		(. doRoutine(function, paras); .) 
			| Asignacion} 
			(IF(isFunction) "regresa" Expresion ';'			(. returns = symbolStack.Pop(); currentCodeBlock.Returns = returns; .)
			|)
		'}'													(. doPopLocals(); currentCodeBlock = currentCodeBlock.Parent; .)
		.

	Asignacion =					(. Variable variable; .)
		Variable<out variable>		(. symbolStack.Push(variable); .)
		'=' Expresion ';'			(. doAssign(); .)
		.

	Funcion<. out Function function, out List<DirectValueSymbol> parameters .> = 
		id				(. string name = t.val; checkFunctionExists(name); .)
		'('				(. parameters = new List<DirectValueSymbol>(); .)
		[ Expresion		(. parameters.Add(symbolStack.Pop()); .)
		{',' Expresion	(. parameters.Add(symbolStack.Pop()); .)
		}] ')'			(. checkParamAmount(name, parameters.Count); .)
						(. function = currentCodeBlock.Search(name) as Function; .)
		.

	Condicion = 
		"si" '(' Expresion ')'							(. var condition = symbolStack.Pop(); DirectValueSymbol returnsDummy; .)
		Bloque<"if", new Variable[]{}, false, out returnsDummy>					(. var ifBlock = currentCodeBlock.Children.Last().CommandList; CommandList elseBlock = null; .)
		[
			"sino" Bloque<"else", new Variable[]{}, false, out returnsDummy>		(. elseBlock = currentCodeBlock.Children.Last().CommandList; .)
		]												(. doIfElse(condition, ifBlock, elseBlock); .)
		.
	
	Ciclo = 
		"mientras" '('							(. createNewSymbolTable("Expression", new List<Variable>());  DirectValueSymbol returnsDummy; .) 
		Expresion								(. var expression = currentCodeBlock.CommandList; var result = symbolStack.Pop(); .)
		')'										(. currentCodeBlock = currentCodeBlock.Parent; .)
		 Bloque<"while", new Variable[]{}, false, out returnsDummy>		(. var whileBlock = currentCodeBlock.Children.Last().CommandList; doWhile(expression, result, whileBlock); .)
		 .
	
	Impresion = "imprimir" '('		(. var expressions = new List<DirectValueSymbol>(); .)
		Expresion					(. expressions.Add(symbolStack.Pop()); .)
		{',' Expresion				(. expressions.Add(symbolStack.Pop()); .)
		} ')' ';'					(. doPrint(expressions); .)
		.
	
	Variable<out Variable variable> = 
		id							(. string name = t.val; checkVariableExists(name); var symbol = currentCodeBlock.Search(name); variable = symbol as Variable; .) 
		['['						
		 Expresion ']'				(. checkIsArray(name); VariableArray array =(symbol as VariableArray); doAssignIndex(array,symbolStack.Pop()); variable = array; .)
		 ].

	Expresion =
		Exp
		{
			(
				"&&"	(. operatorStack.Push(Operator.And); .)
				|"||"	(. operatorStack.Push(Operator.Or); .)
			) 
			Exp			(. doPendingLogical(); .)
		}.
	
	Exp = 
		Expt
		[
			(
				'>'		(. operatorStack.Push(Operator.GreaterThan); .)
				|'<'	(. operatorStack.Push(Operator.LessThan); .)
				|">="	(. operatorStack.Push(Operator.GreaterEqual); .)
				|"<="	(. operatorStack.Push(Operator.LessEqual); .)
				|"<>"	(. operatorStack.Push(Operator.Different); .)
				|"=="	(. operatorStack.Push(Operator.Equality); .)
			) 
			Expt		(. doPendingRelational(); .)
		].
	
	Expt = 
		Termino
		{
			(
				'+'		(. operatorStack.Push(Operator.Sum); .) 
				| '-'	(. operatorStack.Push(Operator.Minus); .)
			) 
			Termino		(. doPendingSum(); .)
		}.
	
	Termino = 
		Factor
		{
			(
				'*'		(. operatorStack.Push(Operator.Multiply); .) 
				|'/'	(. operatorStack.Push(Operator.Divide); .)
				|'%'	(. operatorStack.Push(Operator.Modulo); .)
			) 
			Factor		(. doPendingMultiplication(); .)
		}.
	
	Factor = 
		(
			'('				(. operatorStack.Push(Operator.FakeLimit); .)
			Expresion 
			')'				(. operatorStack.Pop(); .)
		) 
		| 
		(
			[('+' | '-')]			(. DirectValueSymbol symbol; .)
			Constante<out symbol>	(. symbolStack.Push(symbol); .)
		).
	
	Constante<out DirectValueSymbol sym> = (. sym = null; .)
		(cteent							(. sym = constBuilder.IntConstant(t.val); .)
		| ctedbl						(. sym = constBuilder.DecConstant(t.val); .)
		| Ctebol						(. sym = constBuilder.BoolConstant(t.val); .)
		| ctestr						(. sym = constBuilder.StrConstant(t.val); .)
		| Aleatorio						(. sym = constBuilder.DecConstant("0"); doRandom(sym); .)
		| Lectura						(. sym = constBuilder.StrConstant(""); doRead(sym); .)
		| IF(FollowedByLPar())			(. Function function; List<DirectValueSymbol> parameters; Constant result = new Constant();.)
			Funcion<out function, out parameters>		(. doFunction(function, parameters, result); sym = result; .)
		|								(. Variable variable; .)
			Variable<out variable>		(. sym = variable; .)
		).
	
	Aleatorio = "aleatorio" '(' ')'.
	
	Lectura = "lectura" '(' ')'.
	
	Ctebol = "verdadero" | "falso".

END ESpp.